% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AggDat.R
\name{AggDat}
\alias{AggDat}
\title{R6 Class for executing the OFPE data aggregation process}
\description{
R6 Class for executing the OFPE data aggregation process that
consolidates data from various sources into one dataset for analysis and
simulation.

This class takes the inputs selected by a user with the 'AggInputs' class
to direct the data to gather and aggregate together in the database. Most
methods are executed in the database.

There are not outputs in this class, as data is worked with and stored
within the OFPE database. See the 'AggInputs' class for descriptions of the
options for aggregating data. The general workflow consists of extracting the
response variable data from the year of interest, then adding previous year
response variable data based on nearest neighbor or an average, depending on
the selected location of aggregated data ('Grid' vs. 'Observed'). Experimental
data is gathered from the year of interest and the year in which a crop was
previously grown. These data are all cleaned in the same process. Across the
whole field, data are removed when exceeding 5SD from the mean, and within
each 10m grid cell, data are removed when exceeding 2SD from the cell mean.
This occurs regardless of whether 'Grid' or 'Observed' is selected. Then,
data from remotely sensed sources are gathered. The data selected is dependent
on the 'dat_used' variable, which indicates whether to use data from Jan 1 to
Mar 30 for the year of interest or to use data from Jan 1 to Dec 31. This is
discussed more in the 'AggInputs' class documentation. Finally, after all on-farm
and remotely sensed data has been combined into one dataset, this is saved to the
database in the farmer's aggregated ('_a') schema.
}
\seealso{
\code{\link{DBCon}} for the database connection class,
\code{\link{AggGEE}} for the class responsible for aggregating Google Earth
Engine data, \code{\link{AggInputs}} for the inputs required for the aggregation
process.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{aggInputs}}{An object of the 'AggInputs' class containaing the options
for aggregating data. This includes the database connection}

\item{\code{farmidx}}{The ID of the farm in which the field falls within.}

\item{\code{farmeridx}}{The ID of the farmer that owns the farm that the field
falls within.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{AggDat$new()}}
\item \href{#method-aggregateData}{\code{AggDat$aggregateData()}}
\item \href{#method-.createAggTable}{\code{AggDat$.createAggTable()}}
\item \href{#method-.cleanRespData}{\code{AggDat$.cleanRespData()}}
\item \href{#method-.aggRespData}{\code{AggDat$.aggRespData()}}
\item \href{#method-.cleanExpData}{\code{AggDat$.cleanExpData()}}
\item \href{#method-.aggExpData}{\code{AggDat$.aggExpData()}}
\item \href{#method-.clipAggDat}{\code{AggDat$.clipAggDat()}}
\item \href{#method-.aggSSURGO}{\code{AggDat$.aggSSURGO()}}
\item \href{#method-.saveAggDat}{\code{AggDat$.saveAggDat()}}
\item \href{#method-.exportAggDat}{\code{AggDat$.exportAggDat()}}
\item \href{#method-clone}{\code{AggDat$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize an object for executing the process of aggregating OFPE
data. Clears out temporary tables from the database and creates a
temporary table for the field boundary of the field selected.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$new(aggInputs)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{aggInputs}}{An 'AggInputs' R6 class with the user's aggregation
options.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An initialized 'AggDat' object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-aggregateData"></a>}}
\if{latex}{\out{\hypertarget{method-aggregateData}{}}}
\subsection{Method \code{aggregateData()}}{
Execution of the aggregation method for OFPE data. Occurs mainly
within the database using PostGIS tools. Creates a 10m grid, a
temporary aggregation table, extracts and consolidates on-farm data,
aggregates remotely sensed data, and saves to the 'aggregated' schema
for the specified farmer.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$aggregateData()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{None}}{No arguments needed. All required arguments in 'AggInputs'
class.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Aggregated data in the 'farmername_a' schema
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.createAggTable"></a>}}
\if{latex}{\out{\hypertarget{method-.createAggTable}{}}}
\subsection{Method \code{.createAggTable()}}{
Creates a temporary aggregated table in the database for processing.
The dot indicates that this function would be private if not for
documentations sake. Create the initial aggregated table based on the
option, either grid or observed locations. If the grid option is
selected, create the initial aggregated table with the centroid
locations and grid cell identifier. Fill in informational variables
for the farmer and field name, the year data is aggregated for,
and the previous harvest year, as well as whether it is a grid or
observed values (grid vs obs). Finally, upload to database for
aggregation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.createAggTable(db, farmername, fieldname, CY, PY, GRID, dat_used, size)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{db}}{Connection to an OFPE formatted database.}

\item{\code{farmername}}{Name of farmer that owns the field.}

\item{\code{fieldname}}{Name of the field for aggregation.}

\item{\code{CY}}{The year of interest for aggregation (aka 'current year').}

\item{\code{PY}}{The 'previous year' in which the crop was harvested in the field.}

\item{\code{GRID}}{Whether to aggregate data to the centroids of a grid or use
the raw observed data locations.}

\item{\code{dat_used}}{The length of year to gather data over for the CY.}

\item{\code{size}}{Size of grid to make (meters), default = 10.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Temporary table in the database.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.cleanRespData"></a>}}
\if{latex}{\out{\hypertarget{method-.cleanRespData}{}}}
\subsection{Method \code{.cleanRespData()}}{
Go through the cleaning process of cleaning the response variable data.
Removes data that are outside of four standard deviations from the mean
of the response variable and the distance, if supplied. Removes points
within 30m of the field boundary. This table is stored in the farmer's
raw database schema before it is processed and added to the temporary
table in the farmer's aggregated schema. The dot indicates that this
function would be private if not for documentations sake.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.cleanRespData(
  respvar,
  db,
  resp_files,
  boundary_import,
  resp_col,
  year,
  fieldname,
  farmername
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{respvar}}{The response variable to aggregate.}

\item{\code{db}}{Connection to an OFPE database.}

\item{\code{resp_files}}{Files used for aggregation.}

\item{\code{boundary_import}}{Whether the user imported their own field boundary or
using a predefined experimental field in the database.}

\item{\code{resp_col}}{The column in the response variable data that corresponds
to the measured response.}

\item{\code{year}}{The year of the data being aggregated.}

\item{\code{fieldname}}{Name of the field for aggregation.}

\item{\code{farmername}}{Name of the farmer that owns the field for aggregation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Temporary table in farmer's 'raw' schema.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.aggRespData"></a>}}
\if{latex}{\out{\hypertarget{method-.aggRespData}{}}}
\subsection{Method \code{.aggRespData()}}{
Method for aggregating the response variable data in the database. Uses
the output of the .cleanRespData method to add the response variable data
to the aggregated table in the database. if you want to upload PY data
leave CY and PY NULL, otherwise provide at least CY for 'grid' and CY & PY
for 'obs' grid options. Implements a second cleaning process based on the
grid cells where observations outside of one standard deviation of the mean
in each grid cell are omitted. The dot indicates that this function would be
private if not for documentations sake.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.aggRespData(
  db,
  farmername,
  respvar,
  fieldname,
  GRID,
  CY = NULL,
  PY = NULL,
  dat_used,
  size
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{db}}{Connection to an OFPE database.}

\item{\code{farmername}}{Name of the farmer that owns the field for aggregation.}

\item{\code{respvar}}{The response variable to aggregate.}

\item{\code{fieldname}}{Name of the field for aggregation.}

\item{\code{GRID}}{Whether to aggregate data to the centroids of a grid or use
the raw observed data locations.}

\item{\code{CY}}{The year of interest for aggregation (aka the 'current year').
NOTE: that when aggregating "PY" data, leave NULL.}

\item{\code{PY}}{The year prior to the year of interest that a crop was harvested
in the field. NOTE: that when aggregating "PY" data, leave NULL
(Counterintuitive... I know).}

\item{\code{dat_used}}{The length of year to gather data over for the CY.}

\item{\code{size}}{Size of grid to make (meters), default = 10.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Data in temporary aggregated table.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.cleanExpData"></a>}}
\if{latex}{\out{\hypertarget{method-.cleanExpData}{}}}
\subsection{Method \code{.cleanExpData()}}{
Go through the cleaning process of cleaning the experimental variable data.
Removes data that are outside of four standard deviations from the mean
of the resposne variable and the distance, if supplied. Removes points
within 30m of the field boundary. This table is stored in the farmer's
raw database schema before it is processed and added to the temporary
table in the farmer's aggregated schema. Differs from the cleaning of
response variable data because of the different structure of inputs
required for the experimental data and because experimental data may
include polygon data. Implements a second cleaning process
based on the grid cells where observations outside of one standard deviation
of the mean in each grid cell are omitted. The dot indicates that this function
would be private if not for documentations sake.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.cleanExpData(
  exp_files,
  db,
  exp_col,
  farmername,
  year,
  exp_conv,
  expvar,
  CY = TRUE,
  fieldname
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{exp_files}}{The experimental variable files for aggregating.}

\item{\code{db}}{Connection to an OFPE database.}

\item{\code{exp_col}}{The column in the experimental variable data that corresponds
to the measured experimental variable.}

\item{\code{farmername}}{Name of the farmer that owns the field for aggregation.}

\item{\code{year}}{The year of the data being aggregated.}

\item{\code{exp_conv}}{The data.frame containaing the information for the product
formula and any conversion to lbs per acre.}

\item{\code{expvar}}{The experimental variable to aggregate.}

\item{\code{CY}}{Logical, whether the data for aggregation is from the year of
interest (aka the 'current year').}

\item{\code{fieldname}}{Name of the field for aggregation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Temporary table in the farmer's 'raw' schema.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.aggExpData"></a>}}
\if{latex}{\out{\hypertarget{method-.aggExpData}{}}}
\subsection{Method \code{.aggExpData()}}{
Method for aggregating the response variable data in the database. Uses
the output of the .cleanExpData method to add the experimental variable data
to the aggregated table in the database. Assumes current year is true, set
to false to create "prev_EXPVAR" col. A set of points from the grid created
across the fields that the aggregation data is based on is recreated
and clipped to the bounding box of the experimental raw data. The raw experimental
data is then extracted to the grid centroids where missing values are filled with
NULL. This is a difference compared to the previous approach that did this after
aggregation, where some missing values should be missing (field edges, partial files,
etc.) and fills in the gaps within observations (real zeroes where the machine
stopped applying the inptu) are filled with zeroes more reliably. This data is then
used when aggregating experimental data. The The dot indicates that this function
would be private if not for documentations sake.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.aggExpData(
  db,
  farmername,
  expvar,
  GRID,
  CY = TRUE,
  fieldname,
  size,
  exp_files
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{db}}{Connection to an OFPE database.}

\item{\code{farmername}}{Name of the farmer that owns the field for aggregation.}

\item{\code{expvar}}{The experimental variable to aggregate.}

\item{\code{GRID}}{Whether to aggregate data to the centroids of a grid or use
the raw observed data locations.}

\item{\code{CY}}{Logical, whether the data for aggregation is from the year of
interest (aka the 'current year').}

\item{\code{fieldname}}{Name of the field for aggregation.}

\item{\code{size}}{Size of grid to make (meters), default = 10.}

\item{\code{exp_files}}{The experimental variable files for aggregating.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Data in temporary aggregated table.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.clipAggDat"></a>}}
\if{latex}{\out{\hypertarget{method-.clipAggDat}{}}}
\subsection{Method \code{.clipAggDat()}}{
Clip aggregated data to the field boundary. Put the aggregated data
into long lat for raster extraction. Clip the aggregated dataset to
the field boundary for faster processing. If experimental rates are
null convert to zero because the sprayer does not record rather than
recording zeroes. The dot indicates that this function would be private
if not for documentations sake. Put the aggregated data into long lat
for raster extraction. Clip the aggregated dataset to the field boundary
for faster processing. If experimental rates are null convert to zero
because the sprayer does not record rather than recording zeroes.
Also, this function
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.clipAggDat()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{None}}{No arguments needed because of class instantiation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
None.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.aggSSURGO"></a>}}
\if{latex}{\out{\hypertarget{method-.aggSSURGO}{}}}
\subsection{Method \code{.aggSSURGO()}}{
Gather SSURGO soils data if present in the database. Extract the
MUSYM attribute. The dot indicates that this function would be private
if not for documentations sake.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.aggSSURGO()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{None}}{No arguments needed because of class instantiation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
None.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.saveAggDat"></a>}}
\if{latex}{\out{\hypertarget{method-.saveAggDat}{}}}
\subsection{Method \code{.saveAggDat()}}{
Save the temporary aggregated table to the appropriate table in
the OFPE database. Puts the data in the correct farmer's aggregated
schema in the table corresponding to the response variable (respvar).
If using a field boundary from the database and the user selected to
save the data to the database, the aggregated file is added to the
aggregated schema for the variable type (yld, pro, sat). Sat = data
aggregated without response or explanatory variables. This includes
only data collected from remote sensing sources or SSURGO, and are
aggregated to the center points of the gridcells. The dot indicates
that this function would be private if not for documentations sake.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.saveAggDat()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{None}}{No arguments needed because of class instantiation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Aggregated data in the OFPE database.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.exportAggDat"></a>}}
\if{latex}{\out{\hypertarget{method-.exportAggDat}{}}}
\subsection{Method \code{.exportAggDat()}}{
Export the aggregated data to the local file system. Uses the user
inputs for a path to the data. The dot indicates that this function
would be private if not for documentations sake.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$.exportAggDat()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{None}}{No arguments needed because of class instantiation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Exported data from the OFPE database.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AggDat$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
